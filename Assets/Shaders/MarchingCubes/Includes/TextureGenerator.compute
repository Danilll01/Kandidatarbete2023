

#include "PerlinNoise.compute"

//#include "Packages/Noise Shader/Shader/ClassicNoise2D.hlsl"
//#include "Packages/Noise Shader/Shader/ClassicNoise3D.hlsl"
//#include "Packages/Noise Shader/Shader/SimplexNoise2D.hlsl"
//#include "Packages/Noise Shader/Shader/SimplexNoise3D.hlsl"

//float noiseScale = 1;
//float noiseHeightMultiplier = 1;
//float planetSize;

//float fbm(int numLayers, float lacunarity, float persistence, float scale, float3 pos)
//{
//    float noise = 0;
//    float frequency = scale / 100;
//    float amplitude = 1;

//    for (int i = 0; i < numLayers; i++)
//    {
//        float n = 1 - abs(snoise(pos * frequency) * 2 - 1);
//		//n*=n;
//        noise += n * amplitude;

//        amplitude *= persistence;
//        frequency *= lacunarity;
//    }

//    return noise;
//}

//float calculateDensity(int3 cell, float textureResolution)
//{
//    float3 worldPos = (cell / float(textureResolution - 1.0) - 0.5f) * planetSize;

//    float halfS = planetSize / 2;
//    float maxD = length(float3(halfS, halfS, halfS));

//    float fudge = 1;

//    float density = length(worldPos) / (maxD + fudge) - 0.5;

//	// Noise
//    float noise = fbm(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;

//    density += noise;

//    return density;
//}

//Create a sphere on a 3D texture
float4 getTexturePoint(uint3 pos, uint resolution, float radius)
{
    
    //planetSize = radius;
    
    
    //float density = 0;

    //const int b = 1;
    //if (pos.x >= resolution - b || pos.y >= resolution - b || pos.z >= resolution - b)
    //{
    //    density = 1;
    //}
    //else if (pos.x <= b || pos.y <= b || pos.z <= b)
    //{
    //    density = 1;
    //}
    //else
    //{
    //    density = calculateDensity(pos, resolution);
    //}

    ////DensityTexture[pos] = density;
    
    
    //return float4(pos, 100);
    
    
    
    
    
    
    
    int index =
    pos.x +
    pos.y * resolution +
    pos.z * resolution * resolution;
    
    float mid = (resolution >> 1) - .5;
    
    float3 relPos = -(pos - mid) * radius / resolution;
    
    float3 vec = (pos / mid) - 1;
    
    float density = (length(vec) > 1) ? 0 : (1 - length(vec)) * 255;
    
    float noiseValue = (noise(pos/10) + 1) * 0.5f;
    //density *= noiseValue;
    
    return float4(relPos, density);
}




